<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="UTF-8">
        <link rel="icon" href="../img/favicon.ico" type="image/x-icon" />
        <link rel="stylesheet" type="text/css" href="../css/projects.css">
        <link rel="stylesheet" type="text/css" href="../css/left_content.css">
        <link rel="stylesheet" type="text/css" href="../css/icon-link.css">
        <script src="tab_manager.js"></script>
        <title>Jared Massa : Projects</title>

    </head>
    <body onload="set_container_height()" onresize="set_container_height()">
        <div class="left-tab-container" id="left-container">
            <a href="../index.html">
                <div class="back-button">
                    Return to Home
                </div>
            </a>
            <div class="page-title" onclick="display_content(event, 'default')">
                Projects
            </div>

            <button class="title-button">Java Projects</button>
            <div class="accordion-content">
                <button class="content-display-button" onclick="display_content(event, 'game_engine')">2D Game Engine</button>
                <button class="content-display-button" onclick="display_content(event, 'multide')">MultIDE</button>
            </div>

            <button class="title-button">Web Development Projects</button>
            <div class="accordion-content">
                <button class="content-display-button" onclick="display_content(event, 'this_website')">This website</button>
                <button class="content-display-button" onclick="display_content(event, 'h4i_kiva')">H4I: Kiva</button>
            </div>

            <button class="title-button">Sample Title Here</button>
            <div class="accordion-content">
            </div>

        </div>
        <div class="content" id="default" style="display: block">
            <div class="content-title">Welcome to the Projects Page!</div>
            <div style="text-align: center;font-size:30px;">
                Use the series of tabs located on the left of the screen to navigate through some of my favorite projects.
            </div>
        </div>
        <div class="content" id="game_engine">
            <div class="content-title">2D Game Engine</div>
            <div class="Icon-Link-Container">
                <a href="https://github.com/SlamDewey/2d_game_engine" id="git" target="_blank">
                    <div class="Icon-Link" id="git"></div>
                </a>
            </div>
            <div class="content-body">
                <p>
                    This project was my first attempt at making a fully functional 2D game engine written entirely from 
                    scratch in Java.  Let's just say it was a success.
                    The engine is broken up into two main sections: The Physics Engine, and The Graphics Engine.
                    <br />
                    I'll go into detail about both below, but first a quick video introduction:
                    <br />
                    <p>
                        <iframe width="640" height="360" src="https://www.youtube.com/embed/WWz4vQ6KWdI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>
                    </p>
                    </p>
                    First off, I'd like to talk about the physics engine, as I liked this part of the project much more (it was 
                    WAY easier to debug).  The Physics Engine (and all of its classes) is/are stored in the 'src/components' 
                    folder, and because the engine is really quite large, I'll try to cover each sub-section only briefly.
                    <br />
                    <p class="content-subtitle">
                        Physics			{Collider, Transform}
                    </p>
                    <p>
                        There are only Transforms and Colliders that really make up the bulk of the physics engine functionality, 
                        and assuming you don't know what these do I'll describe them quickly.  The Collider contains arrays of 
                        2D vectors (essentially coordinates) that represent a hitbox around the object.  This can either be auto-
                        generated (as in the BoxCollider or EllipseCollider classes) or can be custom written and passed into the 
                        Collider after creation.  Also, as you may expect, the Collider can check if two hitboxes are colliding.  The 
                        Collider class uses a static instance of an enum (defined upon initialization) to choose between two 
                        forms of collision detection.  These are SAT (Separating Axis Theorem) and a standard Vector 
                        Intersection Edge Test.  I won't describe these methods here as I didn't invent them, just implemented.  
                        Finally, the Collider can also perform 2D ray casting, for collision prediction, and general range finding.  
                        The Transform is the simpler of the two. This class manages 2D vectors for position, velocity, force, and 
                        acceleration.  In addition, this class manages object mass, rotation angle, and rotational velocity.  (Shout 
                        tout to Mr. Arner at Springfield Township High School for teaching me these topics in AP Physics C)
                    </p>
                    <br />
                    <p class="content-subtitle">
                        Abstract Classes	{GameObject, CollidableObject, Entity, EnviornmentObject}
                    </p>
                    <p>
                        These abstract classes build the base for abstraction of physics objects.  Essentially a CollidableObject 
                        is an abstract class with a Transform and Collider.  It has a few important methods that can optionally 
                        be overwritten upon 
                        extension: onCollision(CollidableObject obj), onDelete().  Obviously the more important function here is 
                        onCollision(), this is called from the Scene when two objects are detected as 'colliding' during a given 
                        frame.  The Scene calls the function for both objects.   A GameObject is simply a CollidableObject that 
                        also contains a TexturedModel reference (more on this later).
                    </p>
                    <br />
                    <p class="content-subtitle">
                        Physics Scene and 	{Scene, Spacial Decomposition, QuadTree, AABB}
                    </p>
                    <p>
                        The physics Scene management was a pure invention of mine that I am honestly quite proud of.  I based 
                        this on the structure of the Unity3D engine and even took its name 'Scene'.  The way it works is we keep 
                        a linked list of all known GameObjects.  Upon every tick() (called from the math-thread at a set interval) 
                        we tick() the physics Scene and therefore the world.  The Scene begins its massive tick() function by 
                        iterating through all GameObjects and calling their individual tick()'s.  This updates the Transform for 
                        each object and prepares the object for collision detection.  In this same loop, the Scene adds each 
                        object to a QuadTree by defining AABB's (Axis Aligned Bounding Box) for each object.  The QuadTree is a 
                        recursive class designed to accept a high quantity of point particles, and store them in a tree.  The tree is 
                        significant because instead of checking if each object is colliding with any of the other objects, we simple 
                        query the tree for objects within a specified bounds of the object, and check those.  This brings collision 
                        detection performance down from O(n^2) to O(nlogn).  For more information on QuadTree's and 
                        AABB's, visit the <a href="https://en.wikipedia.org/wiki/Quadtree">Wikipedia page about this topic.</a>  Moving on, besides worldwide collision 
                        detection and object management, the Scene also is a camera!  It contains its own Transform (and 
                        therefore position, rotation, velocity, etc) and can move about the physics world.  The viewport 
                        specified by the combination of the Window size, and the Scene's Transform determine which objects 
                        should be drawn by the graphics engine.  As well the focus Transform of the Scene can easily be updated 
                        a reference to any GameObject's Transform, and therefore center that object on the screen.
                    </p>
                    <br />
                    <p class="content-subtitle">
                        The Graphics Engine
                    </p>
                    <p>
                        Now I'll recall some descriptions of the graphics engine itself and its functionality.  The graphics engine 
                        uses OpenGL and GLFW, normally something reserved for web or C++ graphics development, but thanks 
                        to a popular Java library known as LWJGL, this amazing technology is being shifted to Java as well. For 
                        more information about LWJGL, visit their site <a href="https://www.lwjgl.org/"> here </a>.  The LWJGL implementation of GLFW 
                        conveniently threads graphics for you and its extremely easy to set up, so you don't have to worry about 
                        much synchronization.  Thread problems only arise in the physics engine.
                    </p>
                    <br />
                    <p>
                        The structure of the graphics engine is based loosely on a few YouTube series I was able to sit through.  
                        Firstly, I'd like to thank <a href="https://www.youtube.com/user/ThinMatrix/">ThinMatrix</a> for his amazing series on an older version of LWJGL, and for 
                        showing a basic implementation of a graphics engine for a mock-up game.  Although my implementation 
                        was simpler (as mine was 2D, and his was 3D) I followed a similar rendering structure.  I created generic 
                        static definitions of different textures, models, and textured-models (in that order) upon engine startup, 
                        and loaded copies of them into VRAM.  Then I used data coming in from the physics engine to determine 
                        how exactly to scale/translate/rotate these textured-models to represent each object.  I used a 
                        collection of static textured-models because I was simply crafting clones of their vertex arrays, when I 
                        wanted to draw them as an object.  This allowed me to have thousands upon thousands of objects 
                        floating around the screen, drawn very efficiently, because the processor would access the same 
                        memory block upon each render() function call.
                    </p>
                    <br />
                    <p>
                        I used a magical class located in 'src/graphics/GL/entities/' known as a GraphicalEntity that was 
                        attached to every object in my physics engine.  This class acted like a courier of data, transferring only 
                        what the graphics engine cared about into a format it could read.  Having this attached to all physics 
                        objects meant I could easily update the graphics component upon a frame tick() if necessary.
                        </p>
                    
            </div>
        </div>
        <div class="content" id="this_website">
            not butts?
        </div>
        </div>

        <script>
            //onload script
            function set_container_height() {
                document.getElementById('left-container').setAttribute(
                    "style", "height: " + window.innerHeight + "px;"
                );
                var contents = document.getElementsByClassName('content');
                for (var i in contents) {
                    if (contents[i].id == 'default') continue;
                    contents[i].setAttribute(
                        "style", "max-height: " + window.innerHeight + "px;"
                    );
                }
            }
            var acc = document.getElementsByClassName("title-button");
            var i;
            
            for (i = 0; i < acc.length; i++) {
                acc[i].addEventListener('mousedown', function() {
                var panel = this.nextElementSibling;
                if (panel.style.maxHeight){
                    panel.style.maxHeight = null;
                    this.setAttribute("style", "border-bottom: none;padding-bottom:18px;");
                } else {
                    panel.style.maxHeight = panel.scrollHeight + "px";
                    this.setAttribute("style", "border-bottom: 3px solid #272727;padding-bottom:15px;");
                } 
                });
            }
            set_container_height();
        </script>
    </body>
</html>